---
marp: true
theme: default
paginate: true
_paginate: false
header: ''
footer: ''
backgroundColor: white
---

<!-- theme: gaia -->
<!-- _class: lead -->

# Lecture 10 Inter Process Communication(IPC)
## Section 1 Overview of IPC


<br>
<br>

Xiang Yong, Chen Yu, Li Guoliang, Ren Ju

Spring 2023

---

**Outline**

### 1. Overview of IPC
2. Pipe
3. Message Queue
4. Shared memory
5. Signal

---
<style scoped>
{
  font-size: 28px
}
</style>
#### Requirements for IPC

- Challenge: The functionality of a single program is limited.
- The objective of IPC: Multiple processes collaborate to meet the requirements of complex applications
   - Modularization of functionality
   - Isolation between programs
   - Collaboration among multiple programs to accomplish complex tasks

**Definition of Inter process communication(IPC)**: he behavior of exchanging data (sharing or passing) between processes for **interaction** with each other.
![bg right:35% 95%](figs/ipcintro.png)

---
<style scoped>
{
  font-size: 30px
}
</style>
#### Interaction between processes

- Independent process: no interaction with other processes
- Collaborative Process: Interaction between two or more processes
    - Sender Receiver / Client Server

```
❯ cat README.md | grep rcore
$ git clone https://github.com/rcore-os/rCore-Tutorial-v3.git
...
* [x] expand the fs image size generated by `rcore-fs-fuse` to 128MiB
```
- `grep` depends on `cat`
   - The output produced by `cat` such as `grep` is used as its input for string matching

---

#### Ways of Inter-Process Communication
- **Direct communication**: Two processes can transfer information to each other without the need for the kernel to replay it
- **Indirect communication**: Two processes pass messages to each other through system calls and the kernel

![bg right:40% 95%](figs/ipcintro.png)

---
<style scoped>
{
  font-size: 28px
}
table {
  font-size: 20px;
}

</style>
#### IPC Mechanisms
IPC refers to the ability of processes to share or transfer data.

| IPC mechanism | Meaning | Communication method |
| ------------------------ | ---- |---- |
| Pipe  | Unidirectional transfer of byte stream | Indirect communication |
| Message Queue | Receive/send messages through the queue | Indirect communication |
| Signal | Asynchronously send signals to a process for handling | Indirect communication |
| Socket | nter-process networking communication for multi/single machines | Indirect communication |
| Shared Memory | Multiple processes share a physical memory block | Direct communication |
| File | Multiple processes can access the same file | Indirect communication |

---
#### Typical IPC mechanism in UNIX

IPC refers to the ability of processes to share or pass data.

![bg right:60% 67%](figs/ipc-taxonomy.png)

---

#### Basic Interface for message passing
- Send messages
- Receive messages
- Remote Procedure Call (RPC)
- Reply messages

Remote Procedure Call, RPC = send + recv

![bg right:54% 95%](figs/ipcintro.png)

---
#### Blocking or Non-blocking Communication

- Blocking communication:
   - Block send, block receive
- Non-blocking communication:
   - Non-blocking send, non-blocking receive

![bg right:51% 65%](figs/block-unblock-send.png)




---
#### IPC buffer modes

- **Unbounded Capacity**: The sender does not need to wait
- **Bounded Capacity**: The sender must wait when the communication link buffer queue is full.
- **Zero capacity**: The sender must wait for the receiver.

![bg right:47% 95%](figs/buffer-pipe.png)

---

**Outline**

1. Overview of IPC
### 2. Pipe
3. Message Queue
4. Shared memory
5. Signal

---

#### Pipe

A pipe is a mechanism for IPC, also known as an anonymous pipe.

- A fixed-size **byte queue** with reading and writing ends.
- The **reading end** is only used to read from the pipe.
- The **writing end** is only used to write data into the pipe.
- The reading/writing end is represented by  **different file descriptors**

![w:700](figs/pipe.png)

---
#### Create a pipe

`int pipe(int pipefd[2])`
- A pipe can be represented as two file descriptors plus a section of kernel memory.
- When creating a pipe, two file descriptors are returned
   - Read end of the pipe
   - Write end of the pipe

![w:700](figs/pipe-fds.png)


---
#### Application Scenarios of Pipe

- Support communication between related processes
   - Parent-child processes, sibling processes, etc.
- The parent process creates a pipe (two file descriptors)
   - The child process will inherit the file descriptor and read/write the pipe

![w:1100](figs/pipe-fds.png)

---
<style scoped>
{
  font-size: 30px
}
</style>

#### Application Scenarios of Pipe

- Usually, the two processes at both ends of the pipe will each close one file descriptor of the pipe, such as
   - The parent process closes the read descriptor and can only **write data** to the pipe
   - The child process closes the write descriptor and can only **read data** from the pipe.

![bg right:50% 95%](figs/pipe-fds-close.png)


---
#### Pipe Implementation Mechanism


![w:700](figs/pipe-imp.jpg)

 
---
<style scoped>
{
  font-size: 30px
}
</style>

#### Pipe [example](https://gitee.com/chyyuu/os-usrapp-lab/blob/main/c/ipc/pipe/ex1.c)

```
$ gcc -o ex1 ex1.c
$ ./ex1
parents
write: the 0 message.
write: the 1 message.
...
children
read: the 0 message.
read: the 1 message.
...
```
Suggestion: You can practice in your own development environment after class

![bg right:54% 70%](figs/pipe-ex1.png)

---
#### Pipes in the Shell

Just use a vertical bar "**|**" to connect two commands:

```
rCore-Tutorial-v3 on ch7
❯ cat README.md | grep rcore
$ git clone https://github.com/rcore-os/rCore-Tutorial-v3.git
...
* [x] expand the fs image size generated by `rcore-fs-fuse` to 128MiB
```
- Very convenient for writing flexible command line scripts
- Does not support communication between any two processes

---
<style scoped>
{
  font-size: 28px
}
</style>

#### Named pipe
A named pipe, also known as a FIFO, can be created using the *mkfifo* command in a shell.

Both anonymous pipes and named pipes belong to the category of unidirectional communication mechanisms. The difference between the two is that:
- A named pipe can support communication between any two processes.
- Anonymous pipes only support communication between between a parent process and its child processes or between sibling processes.

A named pipe is a blocking unidirectional communication pip:
- Either party can read and write
- Data is only written and read when both the reading and writing ends of the named pipe are opened simultaneously.

---

#### Named Pipes

shell A
```
$ mkfifo name.fifo
$ echo README > name.fifo #The file type is p, and writing to the named pipe is blocking
```
shell B
```
$ cat name.fifo
```

However, named pipes only support unidirectional communication in byte stream form, and do not support bidirectional communication between any two processes.
Named Pipes [Example](https://www.cnblogs.com/52php/p/5840229.html)

---

**Outline**

1. Overview of IPC
2. Pipe
### 3. Message Queue
4. Shared memory
5. Signal

---
<style scoped>
{
  font-size: 30px
}
</style>

#### Message Queue
Message queues are an indirect communication mechanism based on structured data maintained by the OS.
- Each Message is a sequence of bytes with its own **type identifier**
- Messages with the same type identifier form a message queue in **first in, first out** order

![w:1000](figs/msg-q-3.png)

---
#### Message Queue Implementation Mechanism
![w:1000](figs/signal-imp.jpg)

---
#### Message Queue Implementation Mechanism
![w:900](figs/signal-imp2.jpg)


---
#### Message Queue System Calls
<!-- https://zhuanlan.zhihu.com/p/268389190 Linux Interprocess Communication——Message Queue -->
- System calls for message queues
   - msgget ( key, flags) //Get the message queue ID
   - msgsnd ( QID, buf, size, flags ） //send a message
   - msgrcv ( QID, buf, size, type, flags ） //Receive a message
   - msgctl( ... ) // message queue control

Message structure
```
struct msgbuf {
long mtype; /* message type */
char mtext[1]; /* message body */
};
```

---
#### Create a Message Queue
```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
```
Arguments:
- key: the name of a message queue
- msgflg: A set of nine permission flags, used in the same way as the mode flags used when creating a file, such as IPC_CREAT or IPC_EXCL.


---
#### Create a Message Queue
```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
```
Return value:

- Success: msgget returns a non-negative integer, which is the identification code of the message queue.
- Failure: Returns "-1"


---
#### Create a Message Queue
```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
```
So how to get the key value?

- Define the key value by macro
- Generate key value through ftok function


---
<style scoped>
{
  font-size: 33px
}
</style>

#### Send Messages
```
int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);
```
Parameter:
- msgid: message queue identifier returned by msgget function
- msg_ptr: pointer to the data to be sent
- msg_sz: length of the data pointed to by msg_ptr
- msgflg: controls the behavior when the message queue is full or reaches the system limit, such as IPC_NOWAIT which indicates not to wait when the queue is full and returns EAGAIN error.



---
#### Send Messages

```
int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);
```
- Returns 0 on success
- Returns -1 on failure


---
<style scoped>
{
  font-size: 30px
}
</style>

#### Receive Messages
```
int msgrcv(int msgid, void *msg_ptr, size_t msgsz, long int msgtype, int msgflg);
```

- msgid: message queue identifier returned by msgget function
- msg_ptr: pointer to the buffer where the received message will be stored
- msgsz: size in bytes of the buffer pointed to by msg_ptr
- msgtype: used to select which message to receive based on the type of the message
     - msgtype=0 returns the first message in the queue
     - msgtype>0 returns the first message in the queue with type equal to msgtype
     - msgtype<0 returns the first message in the queue with type less than or equal to the absolute value of msgtype




---
<style scoped>
{
  font-size: 30px
}
</style>

#### Receive messages
```
int msgrcv(int msgid, void *msg_ptr, size_t msgsz, long int msgtype, int msgflg);
```
- msgflg: controls the behavior when there is no message available to receive with the specified type
   - IPC_NOWAIT: returns ENOMSG error if no message of the specified type is available
   - MSG_NOERROR: truncates the message if its size is greater than msgsz

return value:
- On success, the number of bytes placed in the buffer is returned
- On failure, -1 is returned


---
#### Message queue [sample program](https://gitee.com/chyyuu/os-usrapp-lab/blob/main/c/ipc/message-queues/ex1.c)
```
$ gcc ex1.c
$ ./a.out
Parent: input message type:
1
Parent: input message to be sent:
test
Parent: input message type:
Child: read msg:test
0
```
Suggestion: You can practice in your own development environment after class

---

**Outline**

1. Overview of IPC
2. Pipe
3. Message Queue
### 4. Shared memory
5. Signal

---
<style scoped>
{
  font-size: 28px
}
</style>

#### Shared memory (Shmem)

Shared memory is a communication mechanism that maps the same physical memory area to the memory address space of multiple processes simultaneously.
- Each process's memory address space needs to explicitly set the shared memory segment.
- Advantages: Quick and convenient data sharing
- Disadvantages: Require synchronization mechanism to coordinate data access.

![w:550](figs/shmem.png)
 

---
#### System calls for shared memory
<!-- https://zhuanlan.zhihu.com/p/147826545 Interprocess Communication of Linux System Programming: Shared Memory -->
- shmget( key, size, flags) // Create shared memory segment
- shmat( shmid, *shmaddr, flags) //map the shared segment to the process address space
- shmdt(*shmaddr)//Unmap the shared memory to process address space
- shmctl(...) //control shared memory

Note: Synchronization mechanisms such as semaphores are required to coordinate access conflicts to shared memory

---
#### Shared Memory Implementation Mechanism

![w:900](figs/shm-imp.jpg)

---
<style scoped>
{
  font-size: 30px
}
</style>

#### Create shared memory
```
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(key_t key, size_t size, int shmflg);
```
- key: IPC key, the return value of ftok().
- size: the length (in bytes) of the shared memory segment.
- shmflg: the flag that specifies the behavior of the function and the permissions of the shared memory, with the following values:
   - IPC_CREAT: Create if it does not exist.
   - IPC_EXCL: returns failure if already exists
- Return value: success: shared memory identifier; failure: -1.



---
<style scoped>
{
  font-size: 30px
}
</style>

#### Shared memory mapping
```
#include <sys/types.h>
#include <sys/shm.h>
void *shmat(int shmid, const void *shmaddr, int shmflg);
```
Maps a shared memory segment into the data segment of the calling process, that is, establishes a relationship between the process and the shared memory so that a process pointer points to this shared memory.


return value:
- Success: the mapped address of the shared memory segment (i.e., the pointer points to this shared memory).
- Failed: -1

---
#### Shared memory mapping
```
void *shmat(int shmid, const void *shmaddr, int shmflg);
```
- shmid: shared memory identifier, the return value of shmget().
- shmaddr: the address where the shared memory is mapped, if NULL, the system will automatically assign it.
- shmflg: the access permission and mapping conditions of the shared memory segment, with the following values:
   - 0: Shared memory has read and write permissions.
   - SHM_RDONLY: read-only.
   - SHM_RND: (valid only when shmaddr is not non-NULL)


---
#### Shared memory [sample program](https://gitee.com/chyyuu/os-usrapp-lab/blob/main/c/ipc/shared-memory/)

```
$ gcc writer.c -o w
$ gcc reader.c -o r
$ ./w
  Writer: copy data to shared-memory
```

---
#### Shared memory example

```
$ ./r
------------ Shared memory segment --------------
Key shmid Owner Permission Bytes Connections Status
0xdf20482b 1 chyyuu 666 512 0

data = [ How are you, mike: from Writer ]
deleted shared-memory

------------ Shared memory segment --------------
Key shmid Owner Permission Bytes Connections Status
```
Suggestion: You can practice in your own development environment after class

---

**Outline**

1. Overview of IPC
2. Pipe
3. Message Queue
4. Shared memory
### 5. Signal

---
<style scoped>
{
  font-size: 30px
}
</style>

#### Signal
- A **signal** is an asynchronous message or event that interrupts a running process
- **Signal mechanism** is a process-level asynchronous notification mechanism.

Question:
- Why can `Ctrl+C` terminate the process?
- How does the `kill` command end the process?

![bg right:50% 95%](figs/signal.png)

---
#### Signal Sending and Response Process
![w:1100](figs/action-imp.jpg)

---
#### Signal Naming
- The signal is an **integer number**, these integer numbers all define the corresponding macro name, and the macro name starts with SIG, such as SIGABRT, SIGKILL, SIGSTOP, SIGCONT
![w:850](figs/signal.png)

---
<style scoped>
{
  font-size: 28px
}
</style>
#### Signal sending
- The process sends a signal through the kernel
   - For example, a shell can terminate a process by sending a signal through the `kill` command
- The kernel can send signals directly
   - For example, if a process reads data from a pipe, but the read permission of the pipe is closed, the kernel sends a SIGPIPE signal to the process to indicate a read error.

![bg right:50% 100%](figs/signal.png)

---
#### Signal Sending
- Peripheral issues via the core
   - For example, when the user presses the Ctrl+C key, the kernel receives an interrupt from the peripheral device that contains the Ctrl+C key and sends a SIGINT signal to the running process to terminate it abnormally.
![bg right:45% 100%](figs/signal.png)


---
#### Signal Handling in Receiving Processes
- Ignore: the signal never happened.
- Catch: the process calls the corresponding signal handling function to process the signal.
- Default: if neither ignored nor caught, the process uses the kernel's default handling method for the signal.
   - The default signal handling in the kernel is usually to kill the process or ignore the signal.
![bg right:45% 100%](figs/signal.png)

---
#### Linux Signals
What are the signals for Linux? -- There are 62 signals.

![w:1150](figs/linux-signal.png)


---
#### Linux Signals

Why are there so many signals?
   - Each signal represents a certain event. In general, when a process receives a signal, it indicates that the event represented by the signal has occurred.
   - For the commonly used signals 1 to 34, it is required to understand rather than memorize them. If you forget the signal name, you can use the kill -l command to check it.

---
#### Common Linux Signals
- SIGKILL
- SIGINT
- SIGSEGV
![bg right:68% 95%](figs/linux-common-signal.png)

---
#### Signal Implementation Mechanism
![w:900](figs/signal-impl.png)

<!-- Ref: Understanding the Linux Kernel
Signals and Inter-Process Communication https://compas.cs.stonybrook.edu/~nhonarmand/courses/fa14/cse506.2/slides/ipc.pdf -->


---
#### Signal Implementation Mechanism

![w:950](figs/CatchingSignal.png)

---
<style scoped>
{
  font-size: 28px
}
</style>

#### Signal Implementation Mechanism
- Register the user-space signal handler `sig_handler`.
- Before returning to user space, the kernel detects the need to handle signals.
- The kernel pushes the `sig_handler` function stack information onto the user stack.
   - Simulate a user code call to the `sig_handler` function.
- The kernel modifies the user-space return address while entering the context.
- The kernel returns to user space and jumps directly to `sig_handler`;
- The `sig_handler` function returns to the old code location to continue execution
![bg right:31% 95%](figs/CatchingSignal.png)

---

#### Signal Application Programming

![w:900](figs/signal-app.png)

---
### Summary
- Mechanism and implementation of pipes
- Mechanism and implementation of message queues
- Mechanism and implementation of shared memory
- Mechanism and implementation of signals
- The relationship between these mechanisms and process control and management.